    val_ret = OK

    if (me->self.id != me->brothers[0][0].id) {

        // me n'étant pas le leader, transfert au leader

        args.cnx_req.new_node_id = new_node_id
        args.cnx_req.try = try

        answer = send_msg_sync(me, TASK_CNX_REQ, me->brothers[0][0].id, args)
        val_ret = answer.cnx_req.val_ret

        set_active(me, new_node_id)

    } else {

        // me est leader
        n = 0

        // rejette la requête si pas disponible

        if ((me->cs_req == 1 && me->cs_new_id != new_node_id) ||
                (state.active == 'u' && state.new_id != new_node_id) ||
                (state.active != 'u' && state.active != 'a')) {

            val_ret = UPDATE_NOK
        } else {

            val_ret = OK

            /*** Demande la permission d'entrer en zone critique ***/

            // set cs_req
            me->cs_req = 1
            me->cs_new_id = new_node_id
            me->cs_req_time = get_clock()

            // combien d'étages faut-il scinder ?
            while ((n < me->height) && (me->bro_index[n] == b)) {

                n++
            }

            // des scissions sont requises
            if (n > 0) {

                /* diffuse cs_req() aux leaders concernés
                   la diffusion est lancée depuis l'étage supérieur au dernier
                   étage scindé à cause de connect_splitted_groups() */

                if (n == me->height) {

                    args.broadcast.stage = n - 1
                } else {

                    args.broadcast.stage = n
                }
                args.broadcast.first_call = 1
                args.broadcast.source_id = me->self.id
                args.broadcast.new_node_id = new_node_id
                args.broadcast.lead_br = 1     // broadcast only to leaders

                args.broadcast.args->cs_req.new_node_id = new_node_id
                args.broadcast.args->cs_req.sender_id = me->self.id
                make_broadcast_task(me, args, &task_sent)

                val_ret = handle_task(me, &task_sent)

                if (val_ret != UPDATE_NOK) {

                    // passe l'état de tous les leaders à 'u' si section critique autorisée
                    args.broadcast.type = TASK_SET_UPDATE

                    if (n == me->height) {

                        args.broadcast.stage = n - 1
                    } else {

                        args.broadcast.stage = n
                    }
                    args.broadcast.first_call = 1
                    args.broadcast.source_id = me->self.id
                    args.broadcast.new_node_id = new_node_id
                    args.broadcast.lead_br = 1     // broadcast only to leaders

                    args.broadcast.args = xbt_new0(u_req_args_t, 1)
                    args.broadcast.args->set_update.new_id = new_node_id
                    make_broadcast_task(me, args, &task_sent)

                    val_ret = handle_task(me, &task_sent)

                    // procède aux scissions
                    for (k = n k > 0 k--) {

                        split_request(me, k, new_node_id)
                    }

                    // repasse l'ensemble des noeuds concernés à 'a'
                    if (n == me->height) {

                        args.broadcast.stage = n - 1
                    } else {

                        args.broadcast.stage = n
                    }
                    args.broadcast.first_call = 1
                    args.broadcast.source_id = me->self.id
                    args.broadcast.new_node_id = new_node_id
                    args.broadcast.lead_br = 0

                    args.broadcast.args = xbt_new0(u_req_args_t, 1)
                    args.broadcast.args->set_active.new_id = new_node_id
                    make_broadcast_task(me, args, &task_sent)

                    handle_task(me, &task_sent)

                } else {

                    // accès à la section critique refusé
                    me->cs_req = 0
                    answer.cnx_req.new_contact.id = -1
                }
            }
        }

        // insère le nouveau noeud si demande acceptée
        if (val_ret != UPDATE_NOK) {

            // le noeud courant doit rester à 'u' jusqu'à la fin
            set_update(me, new_node_id)

            /* informe chaque membre de l'étage 0 qu'il a un nouveau frère */

            // on travaille sur une copie de la table de routage
            cpy_bro_index = me->bro_index[0]
            for (i = 0 i < b i++) {

                cpy_brothers[i] = me->brothers[0][i]
            }

            cpt = 0
            for (i = 0 i < cpy_bro_index i++) {

                if (cpy_brothers[i].id != me->self.id) {

                    /* envoie NEW_BROTHER_RCV à tous les autres membres */
                    args.new_brother_rcv.new_node_id = new_node_id

                    res = send_msg_async(me,
                            TASK_NEW_BROTHER_RCV,
                            cpy_brothers[i].id,
                            args)

                    cpt++
                } else {

                    // appel local
                    new_brother_received(me, new_node_id)
                }
            }

            // construction de la réponse
            answer.cnx_req.new_contact = me->self
            answer.cnx_req.brothers = me->brothers
            answer.cnx_req.bro_index = me->bro_index
            answer.cnx_req.height = me->height
            state = get_state(me)
            answer.cnx_req.contact_state = state

            // le noeud courant peut maintenant passer à 'a'
            set_active(me, new_node_id)

            me->cs_req = 0
            me->cs_req_time = MSG_get_clock()
        }
        answer.cnx_req.val_ret = val_ret
    }

    return answer

