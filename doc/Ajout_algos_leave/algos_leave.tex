\documentclass[11pt,twoside,openright]{report}

% packages
\usepackage{pifont}
\usepackage[french]{babel}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{tikz}
\usepackage{hyphenat}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage[width=16cm,left=3cm,top=3.5cm]{geometry}
\geometry{a4paper}
%\usepackage[french,vlined,tworuled,linesnumbered,algo2e]{algorithm2e}
\usepackage[Algorithme]{algorithm}
\usepackage{algpseudocode}
\usepackage{alltt}
\usepackage{lastpage}
\usepackage{multicol}
\usepackage{color}
\usepackage{moreverb}
\usepackage{graphicx}
\usepackage{paralist}
\usepackage{array}
\usepackage{tabularx}
\usepackage{parskip}
\usepackage{fancyhdr}
\usepackage{changepage}
\usepackage{minitoc}
\usepackage{float}
\usepackage[toc,page]{appendix}
\usepackage{hyperref}
\usepackage{wasysym}

% some definitions
\def\tb{\textbf}
\def\ti{\em}
\def\sc{\textsc}
\definecolor{dark_green}{rgb}{0,0.6,0}

% to set a blank page before an odd chapter page
\def\cleardoublepage{%
  \clearpage
  \ifodd\value{page}\else
    \thispagestyle{empty}%
    \hbox{}\newpage
  \fi
}

% Last page must be empty
\AtEndDocument{\thispagestyle{empty}}

% fancyhdr config
\setlength{\headheight}{15.2pt}
\fancyhead{}
\fancyhead[RE]{\slshape \leftmark}
\fancyhead[LO]{\slshape \rightmark}
\fancyfoot{}
\fancyfoot[LO,RE]{page \thepage\ sur \pageref{LastPage}}
\fancyfoot[LE,RO]{\small{\it{Christophe Enderlin}}}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\fancypagestyle{plain}{
	\fancyhf{}
	\renewcommand{\headrulewidth}{0pt}
	\renewcommand{\footrulewidth}{0pt}
}

% to get part title
\let\Oldpart\part
\newcommand{\parttitle}{}
\renewcommand{\part}[1]{\renewcommand{\parttitle}{#1}\Oldpart{#1}}

%customize lists
\frenchbsetup{ReduceListSpacing=true, CompactItemize=false}

% some commands
\newcommand{\todo}[1]{~\\\noindent{\color{red}\rule[-.1cm]{.5cm}{.5cm}~~{\color{red}{#1}\\}}}
\newcommand{\red}[1]{\color{red}{#1}}
\newcommand{\green}[1]{\color{dark_green}{#1}}
\newcommand{\e}{\acute{e}}
\newcommand{\ee}{\grave{e}}
\newcommand{\eee}{\hat{e}}

\newcommand{\algsuspend}[1]{\algstore{#1}\end{algorithmic}\end{algorithm}}
\newcommand{\algresume}[2]{{\vskip .5cm}\addtocounter{algorithm}{-1}\begin{algorithm}\caption{: \sc{#2} (suite)}\begin{algorithmic}[1]\algrestore{#1}\Statex}

\renewcommand{\And}{\textbf{ and }}

% algorithms customization
\renewcommand{\algorithmiccomment}[1]{{\color{dark_green}\hfill\(\triangleright\) {\small \textsf{#1}}}}
\algnewcommand\algorithmicto{\textbf{to}}
\algrenewtext{For}[3]{$\algorithmicfor\ #1 \gets #2\ \algorithmicto\ (#3)\ \algorithmicdo$}
%\algblock[Name]{Def}{Fin}
\algblock[Test]{switch}{endswitch}
\algrenewtext{endswitch}{\textbf{end switch}}
\algblockdefx[NAME]{case}{endcase}[1]{\textbf{case} (#1) :}{\textbf{break}}

% for titlepage.
\newcommand{\HRule}{\rule{\linewidth}{.5mm}}

% blank page
\newcommand{\blankpage}{\newpage\thispagestyle{empty}\mbox{}}

% to prevent footnotes to be split over several pages
\interfootnotelinepenalty=10000

% Hyperref.
\hypersetup{
	backref=true,
    pagebackref=true,
    hyperindex=true,
    colorlinks=true,
    breaklinks=true,
    urlcolor=blue,
    linkcolor=black,
    citecolor=black,
    bookmarks=true,
    bookmarksopen=true
}

% Minitoc.
\renewcommand{\mtctitle}{Sommaire}
%\setcounter{minitocdepth}{1}

\begin{document}

\chapter{Retrait de sommets d'un DST (suite des travaux)}
\section{Présentation de différents cas de figure}
\subsection{Retraits avec fusion}

\begin{figure}[ht]
\begin{center}
\includegraphics[width=14cm]{Ex_Retrait1.pdf}
\end{center}
\caption{Exemple de retrait: le sommet 40 quitte un DST [2,4]}
\label{f:ExRt1}
\end{figure}

Ici, le départ de 40 laisse un n\oe ud orphelin, le 25, que le groupe à sa droite peut accueillir.
\newpage

\begin{figure}[h]
\begin{center}
\includegraphics[width=13.5cm]{Ex_Retrait2.pdf}
\end{center}
\caption{Exemple de retrait: le sommet 9 quitte un DST [2,4]}
\label{f:ExRt2}
\end{figure}

Cette fois, la fusion de 16 avec le groupe [52 \ldots 14] provoque la fusion de l'étage supérieur (vert) qui a de la place.

\section{Retraits avec transfert}

\begin{figure}[h]
\begin{center}
\includegraphics[width=13cm]{Ex_Retrait3.pdf}
\end{center}
\caption{Exemple de retrait: le sommet 32 quitte un DST [2,4]}
\label{f:ExRt3}
\end{figure}

Les groupes [16 \ldots 14] et [12 \ldots 27] n'ont pas de place pour accueillir 37. Il va donc y avoir un transfert de [7, 27] vers 37. À noter qu'un transfert ne provoque pas de propagation aux étages supérieurs puisqu'il ne réalise qu'une nouvelle répartition des membres d'un étage donné, sans modifier leur nombre, contrairement à la fusion.

\section{Détail des opérations de retrait}
\subsection{La fonction \sc{leave()}}
Lorsqu'un n\oe ud quitte le DST, il doit exécuter la fonction \sc{leave()}\newline

\begin{algorithm}
\caption{: Le départ}
\begin{algorithmic}[1]
\Statex
\Procedure{leave}{ }
	\Statex \Comment{travaille sur des copies des tables de routage}

	\State $cpy\_brothers \gets me.brothers$
	\State $cpy\_preds \gets me.preds$
	\Statex
	\algsuspend{leabrk1}
	
Cette fonction modifiant les tables de routage et de prédécesseurs, on travaille sur des copies de ces tables.
	
	\algresume{leabrk1}{leave}
	\For{stage}{0}{{\tt height}(me.brothers) - 1}
		\Statex \Comment{\textsc {informe mes prédécesseurs de mon départ}}
	
		\For{pred}{0}{{\tt size}(cpy\_preds[stage]) - 1}
			\Statex
		
			\If{$(cpy\_preds[stage][pred].id \neq me.id)$}
				\Statex
			
				\If{$(stage = 0)$}
					\State \Call{send\_msg\_async}{$cpy\_preds[stage][pred].id,\ {\tt del\_bro}(stage,\ me.id)$}
				\Else
					\State {$new\_rep\_id \gets$ un de mes frères de l'étage 0 choisi aléatoirement}
					\Statex
					\State \parbox{\textwidth}{\Call{send\_msg\_async}{$cpy\_preds[stage][pred].id,$
			
					$\qquad{\tt repl\_bro}(stage,\ new\_rep\_id)$}}
				\EndIf
			\EndIf
		\EndFor \Comment{prédécesseur suivant}
		\Statex
		\algsuspend{leabrk2}
		
À chaque étage, le n\oe ud courant doit prévenir chacun de ses prédécesseurs de son départ:
\begin{itemize}
	\item à l'étage 0, le prédécesseur doit simplement ôter ce n\oe ud de sa table de routage. (fonction \sc{del\_bro()})
	\item aux autres étages, le prédécesseur doit utiliser un autre représentant que le n\oe ud courant. (fonction \sc{repl\_bro()}) Ce sera un de ses frères de niveau 0 choisi aléatoirement.
\end{itemize}

\newpage
		
		\algresume{leabrk2}{leave}
		\Statex \Comment{\textsc{informe mes frères de mon départ}}
	
		\For{brother}{0}{{\tt size}(cpy\_brothers[stage]) - 1}
			\Statex
		
			\If{$(cpy\_brothers[stage][brother].id \neq me.id)$}
				\Statex
			
				\State \parbox{\textwidth}{\Call{send\_msg\_async}{$cpy\_brothers[stage][brother].id,$
			
				$\qquad{\tt del\_pred}(stage,\ me.id)$}}
			\EndIf
		\EndFor \Comment{frère suivant}
	\EndFor	\Comment{étage suivant}
	\Statex
	\algsuspend{leabrk3}
	
Ensuite, chacun des frères doit également être prévenu: ils ne peuvent plus avoir le n\oe ud courant comme prédécesseur. (fonction \sc{del\_pred()})
	
	\algresume{leabrk3}{leave}
	\Statex \Comment{\textsc{charge un de mes frères de traiter les fusions ou transferts}}

	\If{$({\tt size}(me.brothers[0]) \leq a)$}
		\Statex
		\State {$idx \gets$ index d'un de mes frères de l'étage 0}
		\State {\Call{send\_msg\_sync}{$me.brothers[0][idx].id,\ {\tt merge\_req}()$}}
	\EndIf
	
\EndProcedure
\end{algorithmic}
\end{algorithm}

Ceci fait, si le groupe courant est devenu trop petit, alors l'un de ses membres est chargé de traiter ce cas en exécutant la fonction \sc{merge\_req()}.

\subsection{La fonction \sc{merge\_req()}}

Cette fonction parcourt le DST de bas en haut, tant que l'étage courant est trop petit. À chaque étage, elle regarde si on doit réaliser une fusion ou un transfert et transmet les ordres en conséquence.

\newcounter{partie}\stepcounter{partie}
\begin{algorithm}
\caption{: Traite les fusions ou transferts consécutifs à un départ}
\begin{algorithmic}[1]
\Statex
\Procedure{merge\_request}{ }
	\Statex

	\State $stage \gets 0$
	\State $size\_last\_stage \gets 0$
	\Statex
	
	\Comment{parcourt l'ensemble des étages si nécessaire}
	\While{$({\tt size}(me.brothers[stage]) < a) \And (stage < {\tt height}(me.brothers) - 1)$}
		\Statex
		
		\State $pos\_contact \gets {\tt merge\_or\_transfer}(me,\ stage)$
		\algsuspend{merbrk1}

C'est la fonction \sc{merge\_or\_transfer()} qui est chargée d'examiner si une fusion est possible. Si c'est le cas, elle retourne la position d'un contact de l'étage supérieur qu'on pourra joindre pour réaliser cette fusion. Sinon, elle retourne -1, auquel cas on réalisera alors un transfert.

		\algresume{merbrk1}{merge\_request}
		\If{$(pos\_contact > -1)$}	\Comment{\textsc{une fusion est possible}}
			\Statex
			
			\State $transfer \gets 0$
			\State $pos\_me \gets {\tt index}(stage + 1,\ me.id)$
			\Statex
			
			\Statex	\Comment{demande au contact de réaliser une première fusion \ldots}
			
			\If{$(pos\_me > pos\_contact)$}
				\State $right \gets 11$
			\Else
				\State $right \gets 10$
			\EndIf
			\Statex
			
			\State \parbox{\textwidth}{\Call{send\_msg\_sync}{$me.brothers[stage + 1][pos\_contact].id,$
					
						$\qquad{\tt merge}(stage,\ pos\_me,\ pos\_contact,\ right,\ me.brothers[stage])$}}
						
			\Statex
			\Statex \Comment{\ldots puis lui demande de diffuser une tâche de fusion}
			
			\If{$(pos\_me > pos\_contact)$}
				\State $right \gets 1$
			\Else
				\State $right \gets 0$
			\EndIf
			\Statex
			
			\State \parbox{\textwidth}{\Call{send\_msg\_sync}{$me.brothers[stage + 1][pos\_contact].id,$
					
						$\qquad{\tt broadcast\_merge}(stage,\ pos\_me,\ pos\_contact,\ right,\ me.brothers[stage])$}}
			\algsuspend{merbrk2}
			
Une fusion est possible. On commence par demander au contact de réaliser une première fusion, puis, sa table de routage étant alors correcte, on lui demande de lancer une diffusion de cette tâche de fusion pour mettre à jour tout son voisinage.

La fonction \sc{merge()} chargée de la fusion proprement dite a besoin de savoir dans quel sens elle doit être réalisée. C'est le rôle de la variable $right$.\footnote{voir les détails de la fonction \sc{merge()} pour les différences entre 1, 11 et 0, 10.}
			
			\algresume{merbrk2}{merge\_request}
			\State \Comment{après la fusion, l'étage supérieur contient deux représentants du même groupe}
			\Statex
			
			\State \Call{clean\_upper\_stage}{$stage,\ pos\_me,\ pos\_contact$} \Comment{exécution locale}
			\Statex \Comment{diffusion}
			
			\State \Call{broadcast}{$me,\ stage + 1,\ {\tt clean\_upper\_stage}{(stage,\ pos\_me,\ pos\_contact)}$}
			
			\algsuspend{merbrk3}

Après la fusion, l'étage supérieur contient deux représentants du même groupe et il faut donc le ``nettoyer''. La fonction \sc{clean\_upper\_stage()} s'en charge. Elle est premièrement exécutée en local pour que sa diffusion se déroule ensuite correctement.

			\algresume{merbrk3}{merge\_request}
		\Else		
			\State \Comment{\textsc{fusion impossible - il faut faire un transfert}}
			
			\State $pos\_me\_up \gets {\tt index}(stage + 1,\ me.id)$ \todo{on peut sortir cette variable puisqu'elle est utilisée dans les deux cas du If}
			%\Statex
			
			\If{$(pos\_me\_up = 0)$}
				
				\State $pos\_contact \gets 1$
				\State $right \gets 0$
				\State $cut\_pos \gets b - a - 1$
			\Else
				
				\State $pos\_contact \gets pos\_me\_up - 1$
				\State $right \gets 1$
				\State $cut\_pos \gets a$
			\EndIf
			\Statex
			
			\State $contact\_id \gets me.brothers[stage + 1][pos\_contact].id$
			\Statex
			
			\State $answer \gets $ \parbox[t]{\textwidth}{\Call{send\_msg\_sync}{$contact\_id,$
			
			$\qquad{\tt transfer}(stage,\ right,\ cut\_pos,\ me.id)$}}L
			
			\algsuspend{merbrk4}
			
La fusion n'étant cette fois pas possible, on demande au groupe voisin (contacté via $contact\_id$) d'exécuter la fonction \sc{transfer()}. Celle-ci le coupe (à la position $cut\_pos$) et retourne les membres extraits dans $answer$.\footnote{Voir le descriptif de cette fonction pour plus de détails}
			
			\algresume{merbrk4}{merge\_request}
			
			\State \Comment{\textsc{ajoute les n\oe uds re\c cus}}
			\Statex
			\State $current\_bro \gets me.brothers[stage]$	\Comment{sauvegarde l'étage courant}
			\Statex
			
			\State \Comment{chaque membre de la branche courante ajoute les n\oe uds re\c cus}
			\State \Call{br\_add\_bro\_array}{$stage,\ answer.rep\_array,\ \mathrm{mod}((right + 1),\ 2$}
			\Statex
			
			\State \Comment{chaque membre du groupe re\c cu ajoute les n\oe uds courants}
			\State \parbox{\textwidth}{\Call{send\_msg\_sync}{$answer.rep\_array[0].id,$
			
			$\qquad{\tt br\_add\_bro\_array}(stage,\ current\_bro,\ right)$}}
			
			\algsuspend{merbrk5}
			
Il s'agit maintenant de fusionner le groupe extrait du voisin avec le groupe courant. \todo{Étudier s'il aurait été possible de réutiliser la fonction \sc{merge()} de la partie fusion. voir aussi la réutilisation de \sc{nouveau\_frère\_re\c cu()}}
La fonction \sc{br\_add\_bro\_array()} diffuse une tâche d'ajout d'un ensemble de membres donné dans le groupe courant.\\Il faut donc réaliser deux diffusions: une sur le groupe courant pour qu'il ajoute les membres extraits et une autre sur le groupe extrait pour qu'il ajoute les membres du groupe courant.
			
			\algresume{merbrk5}{merge\_request}
			\State \Comment{nettoyage de l'étage supérieur}
			\State \Comment{exécution locale}
			\State \Call{update\_upper\_stage}{$stage,\ pos\_contact,\ answer.stay\_id$}
			\Statex
			
			\State \Comment{diffusion}
			\State \parbox{\textwidth}{\Call{broadcast}{$me,\ stage + 1,$
			
			$\qquad{\tt update\_upper\_stage}{(stage,\ pos\_contact,\ answer.stay\_id)}$}}
			
		\EndIf
		\Statex
		
		\State $stage \gets stage + 1$ \Comment{étage suivant}
	\EndWhile
	
	\algsuspend{merbrk6}
	
Tout comme dans la partie fusion, l'étage supérieur contient maintenant deux représentants du même groupe et il faut corriger cela. La fonction \sc{update\_upper\_stage()} s'en charge.
\todo{pourquoi ne pas avoir utilisé \sc{clean\_upper\_stage()} ? expliquer}
Elle est premièrement exécutée en local pour que sa diffusion se déroule ensuite correctement.
\todo{on voit qu'au final, on réalise une fusion dans les deux cas (fusion et transfert). Pas d'harmonisation possible ?}
		
	\algresume{merbrk6}{merge\_request}
			
	\State \Comment{\textsc{traitement de la racine}}
	\Statex
	
	\State $i \gets 0$
	\While{$(me.brothers[0][i].id = me.id)$}
		\State $i \gets i + 1$
	\EndWhile
	\Statex
	
	\State $size\_last\_stage \gets $ \parbox[t]{\textwidth}{\Call{send\_msg\_sync}{$me.brothers[0][i].id,$
	
	$\qquad {\tt get\_size}({\tt height}(me.brothers) - 1)$}}
	\Statex
	
	\If{$(size\_last\_stage = 1)$}	\Comment{détruit la racine}
		\Statex
		
		\State \parbox{\textwidth}{\Call{broadcast}{$me,\ {\tt height}(me.brothers) - 1,\ {\tt del\_root}{({\tt height}(me.brothers))}$}}
	\EndIf
\EndProcedure
\end{algorithmic}
\end{algorithm}

Une fois l'ensemble des étages parcouru, on examine la racine. Si elle ne comporte qu'un enfant, c'est qu'il faut la supprimer. On diffuse pour cela la fonction \sc{del\_root()} sur l'ensemble du DST.

\begin{algorithm}
\caption{: Transfert de n\oe uds du groupe courant vers un groupe appelant}\label{a:tr}
\begin{algorithmic}[1]
\Statex
\Procedure {transfer}{$st,\ right,\ cut\_pos$}
	\If{$(right = 1)$}
		\State $start \gets cut\_pos$
		\State $end \gets {\tt size}(me.brothers[stage]) - 1$
		\State $answer.stay\_id \gets me.brothers[stage][cut\_pos - 1].id$
	\Else
		\State $start \gets 0$
		\State $end \gets cut\_pos$
		\State $answer.stay\_id \gets me.brothers[st][cut\_pos + 1].id$
	\EndIf
	\Statex
	\For{i}{start}{end}
		\State $answer.rep\_array[i - start] = me.brothers[st][i]$
	\EndFor
	\Statex
	\State \Call {broadcast}{$me,\ st,\ {\tt cut\_node}{(st,\ right,\ cut\_pos)}$}
	\Statex
	\State \Return $answer$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{: Scinde un n\oe ud lors d'un transfert}\label{a:cn}
\begin{algorithmic}[1]
\Statex
\Procedure{cut\_node}{$stage,\ right,\ cut\_pos$}
	\State $pos\_me \gets {\tt index}(me.brothers[stage],\ me.id)$
	\Statex
	
	\If{$(right = 0)$}
		\State $start \gets 0$
		\State $end \gets cut\_pos$
		\State $new\_node \gets me.brothers[stage][cut\_pos + 1]$
	\Else
		\State $start \gets cut\_pos$
		\State $end \gets {\tt size}(me.brothers[stage]) - 1$
		\State $new\_node \gets me.brothers[stage][0]$
	\EndIf
	\Statex
	
	\If{$(pos\_me \geq start \And pos\_me \leq end)$}
		\State \Call {shift\_bro}{$stage + 1,\ new\_node,\ right$}
	\EndIf
	\Statex
	
	\If{$(right = 0)$}
		\If{$(pos\_me \leq cut\_pos)$}
			\State $start \gets cut\_pos + 1$
			\State $end \gets {\tt size}(me.brothers[stage] - 1)$
		\Else
			\State $start \gets 0$
			\State $end \gets cut\_pos$
		\EndIf
	\Else
		\If{$(pos\_me < cut\_pos)$}
			\State $start \gets cut\_pos$
			\State $end \gets {\tt size}(me.brothers[stage] - 1)$
		\Else
			\State $start \gets 0$
			\State $end \gets cut\_pos - 1$
		\EndIf
	\EndIf
	\Statex
	
	\State \Call {del\_member}{$stage,\ start,\ end$}
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{: Supprime une partie du groupe courant à un étage donné}\label{a:dm}
\begin{algorithmic}[1]
\Statex
\Procedure{del\_member}{$stage,\ start,\ end$}
	\State $nb\_del \gets end - start + 1$
	\If{$(nb\_del = 0)$}
		\State \Return
	\EndIf
	\Statex	\Comment{mémorise les n\oe uds à effacer avant de commencer}
	
	\For{i}{0}{nb\_del - 1}
		\State $id\_del[i] \gets me.brothers[stage][start + i].id$
	\EndFor
	\Statex		\Comment{boucle d'effacement}
	
	\For{i}{0}{nb\_del - 1}
		\If{$(id\_del[i] <> me.id)$}	\Comment{ne pas effacer '{\ti moi}'}
			\State $pos2del \gets {\tt index}(me.brothers[stage], id\_del[i])$
			\Statex
			
			\If{$(pos2del < {\tt size}(me.brothers[stage] - 1))$}
				\For{j}{pos2del}{{\tt size}(me.brothers[stage] - 1)}
					\State $me.brothers[stage][j] \gets me.brothers[stage][j + 1]$
				\EndFor
			\Else
				\State $j \gets pos2del$
			\EndIf
			\Statex
			
			\State $me.brothers[stage][j].id \gets -1$
			\Statex		\Comment{'{\ti moi}' n'est plus prédécesseur de $id\_del[i]$}
			
			\State \Call{send\_msg\_async}{$id\_del[i],\ {\tt del\_pred}(stage,\ me.id)$}			
		\EndIf
	\EndFor
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{: Décale les membres du groupe pour en accueillir un nouveau à la position de '{\ti moi}'. Le membre en trop est détruit.}
\begin{algorithmic}[1]
\Statex
\Procedure{shift\_bro}{$stage,\ new\_node,\ right$}
	\Statex		\Comment{s'assure de n'exécuter cette fonction qu'une fois (elle est diffusée par {\tt cut\_node})}
	\State $pos\_new\_node \gets {\tt index}(me.brothers[stage],\ new\_node.id)$
	\If{$(pos\_new\_node > -1)$}
		\State \Return
	\EndIf
	\Statex
	
	\State $pos\_me \gets {\tt index}(me.brothers[stage],\ me.id)$
	\Statex
	
	\If{$(right = 1)$}
		\If{$(pos\_me < b)$}
			\State $lost\_id \gets me.brothers[stage][pos\_me + 1].id$
			\State $me.brothers[stage][pos\_me + 1] \gets me.brothers[stage][pos\_me]$
		\Else
			\State Affiche un message d'erreur et stoppe la procédure
		\EndIf
	\Else
		\If{$(pos\_me > 0)$}
			\State $lost\_id \gets me.brothers[stage][pos\_me - 1].id$
			\State $me.brothers[stage][pos\_me - 1] \gets me.brothers[stage][pos\_me]$
		\Else
			\State Affiche un message d'erreur et stoppe la procédure
		\EndIf
	\EndIf
	\Statex
	
	\State $me.brothers[stage][pos\_me] \gets new\_node$
	\Statex
	\Statex		\Comment{'{\ti moi}' doit être un prédécesseur de {\ti new\_node}}
	\State \Call{send\_msg\_async}{$new\_node.id,\ {\tt add\_pred}(stage,\ me.id)$}
	
	\Statex		\Comment{'{\ti moi}' ne doit plus être un prédécesseur de {\ti lost\_id}}
	\State \Call{send\_msg\_async}{$lost\_id,\ {\tt del\_pred}(stage,\ me.id)$}
	
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{: regarde s'il faut faire une fusion ou un transfert. Retourne la position d'un contact pour la fusion ou -1 si tranfert}
\begin{algorithmic}[1]
\Procedure{merge\_or\_transfert}{$stage$}
	\Statex
	
	\State $idx\_bro \gets 0$
	\State $merge \gets 0$
	\Statex
	
	\While{$(merge = 0 \And idx\_bro < {\tt size}(me.brothers[stage + 1]))$}
		\Statex
		
		\If{$(me.brothers[stage + 1][idx\_bro].id \neq me.id)$}
			\Statex
			
			\State $size \gets $ \parbox[t]{\textwidth}{\Call{send\_msg\_sync}{$me.brothers[stage + 1].[idx\_bro].[id],$
			
			$\qquad {\tt get\_size}(stage)$}}
			\Statex
			
			\If{$(size \leq b - {\tt size}(me.brothers[stage]))$}
				\State $merge \gets 1$
			\EndIf
		\EndIf
		\Statex
		
		\State $idx\_bro \gets idx\_bro + 1$
	\EndWhile
	\Statex
	
	\If{$(merge = 1)$}
		\State \Return $idx\_bro - 1$
	\Else
		\State \Return $-1$
	\EndIf
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{: fusionne des n\oe uds ``orphelins'' (\emph{source}) au groupe courant (\emph{cible})}
\begin{algorithmic}[1]
\Procedure{merge}{$nodes\_array,\ nodes\_array\_size,\ stage,\ pos\_me,\ pos\_contact,\ right$}
	\Statex
	
	\If{$({\tt size}(nodes\_array) = {\tt size}(me.brothers[stage]))$} \Comment{déjà fait}
		\State \Return
	\EndIf
	\Statex
	
	\If{$({\tt size}(me.brothers[stage]) < a)$} \Comment{change le sens d'arrivée si 'moi' est dans la source}
		\State $right \gets \mathrm{mod}((right + 1),\ 2)$
	\EndIf
	\Statex
	
	\State $loc\_right \gets 0$
	\Statex
	
	\switch $\ (right)$
		\case{$0$}	\Comment{les nouveaux n\oe uds viennent de la gauche - diffusion}
			\If{$({\tt index}(stage + 1,\ me.id) = 0)$}
				\State $loc\_right \gets 1$
			\Else
				\State $loc\_right \gets 0$
			\EndIf
		\endcase
		\Statex
		
		\case{$1$}	\Comment{les nouveaux n\oe uds viennent de la droite - diffusion}
			\If{$({\tt index}(stage + 1,\ me.id) = {\tt size}(me.brothers[stage + 1] - 1))$}
				\State $loc\_right \gets 0$
			\Else
				\State $loc\_right \gets 1$
			\EndIf
		\endcase
		\Statex
		
		\case{$10$}	\Comment{les nouveaux n\oe uds viennent de la gauche - 1ère fusion}
			\State $loc\_right \gets 0$
		\endcase
		\Statex
		
		\case{$11$}	\Comment{les nouveaux n\oe uds viennent de la droite - 1ère fusion}
			\State $loc\_right \gets 1$
		\endcase
	\endswitch
	\Statex
	
	\State \Comment{nombre de n\oe uds à incorporer}
	\If{$(nodes\_array\_size \geq {\tt size}(me.brothers[stage]))$}
		\State $loc\_nodes\_array\_size \gets nodes\_array\_size - {\tt size}(me.brothers[stage])$
	\Else		
		\State $loc\_nodes\_array\_size \gets nodes\_array\_size$
	\EndIf
	\Statex
	
	\algstore{algbrk3}
	\end{algorithmic}
	\end{algorithm}
		
	\newpage
		
	\addtocounter{algorithm}{-1}
	\setcounter{partie}{1}
	\stepcounter{partie}
	\begin{algorithm}
	\caption{: \textsc{merge} (partie \thepartie)}
	\begin{algorithmic}[1]
	\algrestore{algbrk3}
	
	\If{$(loc\_right = 0)$}	\Comment{prend la partie gauche de la liste des n\oe uds fournie}
		\If{$(loc\_nodes\_array\_size > 0)$}
			\For{i}{0}{loc\_nodes\_array\_size-1}
				\State $loc\_nodes\_array[i] \gets nodes\_array[i]$
			\EndFor
		\EndIf
	\Else	\Comment{prend la partie droite de la liste des n\oe uds fournie}
		\If{$(loc\_nodes\_array\_size > 0)$}
			\For{i}{(nodes\_array\_size - loc\_nodes\_array\_size)}{\mbox{$(nodes\_array\_size - 1)$}}
				\State \parbox{\textwidth}{$loc\_nodes\_array[i - (nodes\_array\_size - loc\_nodes\_array\_size)] \gets nodes\_array[i]$}
			\EndFor
		\EndIf
	\EndIf
	\Statex
	
	\If{$(loc\_nodes\_array\_size > 0)$}
		\If{$(loc\_right = 0)$}	\Comment{insère les nouveaux frères au début (gauche)}
			\Statex
			
			\For{i}{loc\_nodes\_array\_size - 1}{0}				
				\State \Call{insert\_bro}{$stage,\ loc\_nodes\_array[i]$}
				\State \Call{send\_msg\_async}{$loc\_nodes\_array[i],\ {\tt add\_pred}(stage,\ me.id)$}
			\EndFor
		\Else	\Comment{ajoute les nouveaux frères à la fin (droite)}
			\Statex
			
			\For{i}{0}{loc\_nodes\_array\_size - 1}				
				\State \Call{add\_brother}{$stage,\ loc\_nodes\_array[i]$}
				\State \Call{send\_msg\_async}{$loc\_nodes\_array[i],\ {\tt add\_pred}(stage,\ me.id)$}
			\EndFor
		\EndIf
	\EndIf
\EndProcedure
\end{algorithmic}
\end{algorithm}

\end{document}











