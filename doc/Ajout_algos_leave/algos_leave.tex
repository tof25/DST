% !TEX root = ../RapportM2.tex

\chapter{Retrait de sommets d'un DST (suite des travaux)}
\section{Transfert}

\begin{algorithm}
\caption{: Transfert de n\oe uds du groupe courant vers un groupe appelant}\label{a:tr}
\begin{algorithmic}[1]
\Statex
\Procedure {transfert}{$st,\ right,\ cut\_pos$}
	\If{$(right = 1)$}
		\State $start \gets cut\_pos$
		\State $end \gets {\tt size}(me.brothers[stage]) - 1$
		\State $answer.stay\_id \gets me.brothers[stage][cut\_pos - 1].id$
	\Else
		\State $start \gets 0$
		\State $end \gets cut\_pos$
		\State $answer.stay\_id \gets me.brothers[st][cut\_pos + 1].id$
	\EndIf
	\Statex
	\For{i}{start}{end}
		\State $answer.rep\_array[i - start] = me.brothers[st][i]$
	\EndFor
	\Statex
	\State \Call {broadcast}{$me,\ st,\ {\tt cut\_node}{(st,\ right,\ cut\_pos)}$}
	\Statex
	\State \Return $answer$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{: Scinde un n\oe ud lors d'un transfert}\label{a:cn}
\begin{algorithmic}[1]
\Statex
\Procedure{cut\_node}{$stage,\ right,\ cut\_pos$}
	\State $pos\_me \gets {\tt index}(me.brothers[stage],\ me.id)$
	\Statex
	
	\If{$(right = 0)$}
		\State $start \gets 0$
		\State $end \gets cut\_pos$
		\State $new\_node \gets me.brothers[stage][cut\_pos + 1]$
	\Else
		\State $start \gets cut\_pos$
		\State $end \gets {\tt size}(me.brothers[stage]) - 1$
		\State $new\_node \gets me.brothers[stage][0]$
	\EndIf
	\Statex
	
	\If{$(pos\_me \geq start$ \And $pos\_me \leq end)$}
		\State \Call {shift\_bro}{$stage + 1,\ new\_node,\ right$}
	\EndIf
	\Statex
	
	\If{$(right = 0)$}
		\If{$(pos\_me \leq cut\_pos)$}
			\State $start \gets cut\_pos + 1$
			\State $end \gets {\tt size}(me.brothers[stage] - 1)$
		\Else
			\State $start \gets 0$
			\State $end \gets cut\_pos$
		\EndIf
	\Else
		\If{$(pos\_me < cut\_pos)$}
			\State $start \gets cut\_pos$
			\State $end \gets {\tt size}(me.brothers[stage] - 1)$
		\Else
			\State $start \gets 0$
			\State $end \gets cut\_pos - 1$
		\EndIf
	\EndIf
	\Statex
	
	\State \Call {del\_member}{$stage,\ start,\ end$}
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{: Supprime une partie du groupe courant à un étage donné}\label{a:dm}
\begin{algorithmic}[1]
\Statex
\Procedure{del\_member}{$stage,\ start,\ end$}
	\State $nb\_del \gets end - start + 1$
	\If{$(nb\_del = 0)$}
		\State \Return
	\EndIf
	\Statex	\Comment{mémorise les n\oe uds à effacer avant de commencer}
	
	\For{i}{0}{nb\_del - 1}
		\State $id\_del[i] \gets me.brothers[stage][start + i].id$
	\EndFor
	\Statex		\Comment{boucle d'effacement}
	
	\For{i}{0}{nb\_del - 1}
		\If{$(id\_del[i] <> me.id)$}	\Comment{ne pas effacer '{\ti moi}'}
			\State $pos2del \gets {\tt index}(me.brothers[stage], id\_del[i])$
			\Statex
			
			\If{$(pos2del < {\tt size}(me.brothers[stage] - 1))$}
				\For{j}{pos2del}{{\tt size}(me.brothers[stage] - 1)}
					\State $me.brothers[stage][j] \gets me.brothers[stage][j + 1]$
				\EndFor
			\Else
				\State $j \gets pos2del$
			\EndIf
			\Statex
			
			\State $me.brothers[stage][j].id \gets -1$
			\Statex		\Comment{'{\ti moi}' n'est plus prédécesseur de $id\_del[i]$}
			
			\State \Call{send\_msg\_async}{$id\_del[i],\ {\tt del\_pred}(stage,\ me.id)$}			
		\EndIf
	\EndFor
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{: Décale les membres du groupe pour en accueillir un nouveau à la position de '{\ti moi}'. Le membre en trop est détruit.}
\begin{algorithmic}[1]
\Statex
\Procedure{shift\_bro}{$stage,\ new\_node,\ right$}
	\Statex		\Comment{s'assure de n'exécuter cette fonction qu'une fois (elle est diffusée par {\tt cut\_node})}
	\State $pos\_new\_node \gets {\tt index}(me.brothers[stage],\ new\_node.id)$
	\If{$(pos\_new\_node > -1)$}
		\State \Return
	\EndIf
	\Statex
	
	\State $pos\_me \gets {\tt index}(me.brothers[stage],\ me.id)$
	\Statex
	
	\If{$(right = 1)$}
		\If{$(pos\_me < b)$}
			\State $lost\_id \gets me.brothers[stage][pos\_me + 1].id$
			\State $me.brothers[stage][pos\_me + 1] \gets me.brothers[stage][pos\_me]$
		\Else
			\State Affiche un message d'erreur et stoppe la procédure
		\EndIf
	\Else
		\If{$(pos\_me > 0)$}
			\State $lost\_id \gets me.brothers[stage][pos\_me - 1].id$
			\State $me.brothers[stage][pos\_me - 1] \gets me.brothers[stage][pos\_me]$
		\Else
			\State Affiche un message d'erreur et stoppe la procédure
		\EndIf
	\EndIf
	\Statex
	
	\State $me.brothers[stage][pos\_me] \gets new\_node$
	\Statex
	\Statex		\Comment{'{\ti moi}' doit être un prédécesseur de {\ti new\_node}}
	\State \Call{send\_msg\_async}{$new\_node.id,\ {\tt add\_pred}(stage,\ me.id)$}
	
	\Statex		\Comment{'{\ti moi}' ne doit plus être un prédécesseur de {\ti lost\_id}}
	\State \Call{send\_msg\_async}{$lost\_id,\ {\tt del\_pred}(stage,\ me.id)$}
	
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{: Procédure exécutée par un n\oe ud qui quitte le DST}
\begin{algorithmic}[1]
\Statex
\Procedure{leave}{ }
	\Statex \Comment{travaille sur des copies des tables de routage}

	\State $cpy\_brothers \gets me.brothers$
	\State $cpy\_preds \gets me.preds$
	\Statex

	\For{stage}{0}{{\tt height}(me.brothers) - 1}
		\Statex \Comment{\textsc {informe mes prédécesseurs de mon départ}}
	
		\For{pred}{0}{{\tt size}(cpy\_preds[stage]) - 1}
			\Statex
		
			\If{$(cpy\_preds[stage][pred].id \neq me.id)$}
				\Statex
			
				\If{$(stage = 0)$}
					\State \Call{send\_msg\_async}{$cpy\_preds[stage][pred].id,\ {\tt del\_bro}(stage,\ me.id)$}
				\Else
					\Statex
					\State {$new\_rep\_id \gets$ un de mes frères de l'étage 0 choisi aléatoirement}
					\Statex \Comment{en informe le prédécesseur}
				
					\If{$(new\_rep\_id \neq me.id)$}
						\Statex
						\State \parbox{\textwidth}{\Call{send\_msg\_async}{$cpy\_preds[stage][pred].id,$
					
						$\qquad{\tt repl\_bro}(stage,\ new\_rep\_id)$}}
					\EndIf
				\EndIf
			\EndIf
		\EndFor \Comment{prédécesseur suivant}
		\Statex
		\Statex \Comment{\textsc{informe mes frères de mon départ}}
	
		\For{brother}{0}{{\tt size}(cpy\_brothers[stage]) - 1}
			\Statex
		
			\If{$(cpy\_brothers[stage][brother].id \neq me.id)$}
				\Statex
			
				\State \parbox{\textwidth}{\Call{send\_msg\_async}{$cpy\_brothers[stage][brother].id,$
			
				$\qquad{\tt del\_pred}(stage,\ me.id)$}}
			\EndIf
		\EndFor \Comment{frère suivant}
	\EndFor	\Comment{étage suivant}
	\Statex
	\Statex \Comment{\textsc{charge un de mes frères de traiter les fusions ou transferts}}

	\If{$({\tt size}(me.brothers[0]) \leq a)$}
		\Statex
		\State {$idx \gets$ index d'un de mes frères de l'étage 0}
		\State {\Call{send\_msg\_sync}{$me.brothers[0][idx].id,\ {\tt merge\_req}()$}}
	\EndIf
	
\EndProcedure
\end{algorithmic}
\end{algorithm}


\begin{algorithm}
\caption{: Traite les fusions ou transferts rendus nécessaires par un départ}
\begin{algorithmic}[1]
\Procedure{merge\_request}{ }
	\Statex

	\State $stage \gets 0$
	\State $size\_last\_stage \gets 0$
	\Statex
	
	\Comment{parcourt l'ensemble des étages}
	\While{$({\tt size}(me.brothers[stage]) < a) \And stage < {\tt height}(me.brothers) - 1)$}
		\Statex
		
		\State $pos\_contact \gets {\tt merge\_or\_transfer}(me,\ stage)$
		\Statex
		
		\If{$(pos\_contact > -1)$}	\Comment{\textsc{une fusion est possible}}
			\Statex
			
			\State $transfer \gets 0$
			\State $pos\_me \gets {\tt index}(stage + 1,\ me.id)$
			\Statex
			
			\Statex	\Comment{demande au contact de réaliser une première fusion \ldots}
			
			\If{$(pos\_me > pos\_contact)$}
				\State $right \gets 11$
			\Else
				\State $right \gets 10$
			\EndIf
			\Statex
			
			\State \parbox{\textwidth}{\Call{send\_msg\_sync}{$me.brothers[stage + 1][pos\_contact].id,$
					
						$\qquad{\tt merge}(stage,\ pos\_me,\ pos\_contact,\ right,\ me.brothers[stage])$}}
						
			\Statex
			\Statex \Comment{\ldots puis lui demande de diffuser une tâche de fusion}
			
			\If{$(pos\_me > pos\_contact)$}
				\State $right \gets 1$
			\Else
				\State $right \gets 0$
			\EndIf
			\Statex
			
			\State \parbox{\textwidth}{\Call{send\_msg\_sync}{$me.brothers[stage + 1][pos\_contact].id,$
					
						$\qquad{\tt broadcast\_merge}(stage,\ pos\_me,\ pos\_contact,\ right,\ me.brothers[stage])$}}
			\Statex
			
			\State \Comment{après la fusion, l'étage supérieur contient deux représentants du même groupe}
			\Statex
			
			\State \Call{clean\_upper\_stage}{stage,\ pos\_me,\ pos\_contact} \Comment{exécution locale}
			\Statex \Comment{diffusion}
			
			\State \Call{broadcast}{$me,\ stage + 1,\ {\tt clean\_upper\_stage}{(stage,\ pos\_me,\ pos\_contact)}$}	
			\Statex
				
		\Else
		
		\algstore{algbrk}
		\end{algorithmic}
		\end{algorithm}
		
		\newpage
		
		\begin{algorithm}
		%\caption{merge\_request (suite)}
		\begin{algorithmic}[1]
		\algrestore{algbrk}
			
			\Statex \State \Comment{\textsc{fusion impossible - il faut faire un transfert}}
			\Statex
			
			\State $pos\_me\_up \gets {\tt index}(stage + 1,\ me.id)$
			\Statex
			
			\If{$(pos\_me\_up = 0)$}
				\Statex
				
				\State $pos\_contact \gets 1$
				\State $right \gets 0$
				\State $cut\_pos \gets b - a - 1$
			\Else
				\Statex
				
				\State $pos\_contact \gets pos\_me\_up - 1$
				\State $right \gets 1$
				\State $cut\_pos \gets a$
			\EndIf
			\Statex
			
			\State $contact\_id \gets me.brothers[stage + 1][pos\_contact].id$
			\Statex
			
			\State $answer \gets $ \parbox[t]{\textwidth}{\Call{send\_msg\_sync}{$contact\_id,$
			
			$\qquad{\tt transfer}(stage,\ right,\ cut\_pos,\ me.id)$}}
			\Statex \Statex
			\State \Comment{\textsc{ajoute les n\oe uds re\c cus}}
			\Statex
			\State $current\_bro \gets me.brothers[stage]$	\Comment{sauvegarde l'étage courant}
			\Statex
			
			\State \Comment{chaque membre de la branche courante ajoute les n\oe uds re\c cus}
			\State \Call{br\_add\_bro\_array}{$stage,\ answer.rep\_array,\ \mathrm{mod}((right + 1),\ 2$}
			\Statex
			
			\State \Comment{chaque membre de la branche voisine ajoute les n\oe uds courants}
			\State \parbox{\textwidth}{\Call{send\_msg\_sync}{$answer.rep\_array[0].id,$
			
			$\qquad{\tt br\_add\_bro\_array}(stage,\ current\_bro,\ right)$}}
			\Statex
			
			\State \Comment{nettoyage de l'étage supérieur}
			\State \Comment{exécution locale}
			\State \Call{update\_upper\_stage}{$stage,\ pos\_contact,\ answer.stay\_id$}
			\Statex
			
			\State \Comment{diffusion}
			\State \parbox{\textwidth}{\Call{broadcast}{$me,\ stage + 1,$
			
			$\qquad{\tt update\_upper\_stage}{(stage,\ pos\_contact,\ answer.stay\_id)}$}}
			
		\EndIf
		\Statex
		
		\State $stage \gets stage + 1$ \Comment{étage suivant}
	\EndWhile
	
	\algstore{algbrk2}
	\end{algorithmic}
	\end{algorithm}
		
	\newpage
		
	\begin{algorithm}
	%\caption{merge\_request (suite)}
	\begin{algorithmic}[1]
	\algrestore{algbrk2}
		
	\State \Comment{\textsc{traitement de la racine}}
	\Statex
	
	\State $i \gets 0$
	\While{$(me.brothers[0][i].id = me.id)$}
		\State $i \gets i + 1$
	\EndWhile
	\Statex
	
	\State $size\_last\_stage \gets $ \parbox[t]{\textwidth}{\Call{send\_msg\_sync}{$me.brothers[0][i].id,$
	
	$\qquad {\tt get\_size}({\tt height}(me.brothers) - 1)$}}
	\Statex
	
	\If{$(size\_last\_stage = 1)$}	\Comment{détruit la racine}
		\Statex
		
		\State \parbox{\textwidth}{\Call{broadcast}{$me,\ {\tt height}(me.brothers) - 1,\ {\tt del\_root}{({\tt height}(me.brothers))}$}}
	\EndIf
\EndProcedure
\end{algorithmic}
\end{algorithm}












