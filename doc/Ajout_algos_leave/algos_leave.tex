\documentclass[11pt,twoside,openright]{report}

% packages
\usepackage{pifont}
\usepackage[french]{babel}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{tikz}
\usepackage{hyphenat}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage[width=16cm,left=3cm,top=3.5cm]{geometry}
\geometry{a4paper}
%\usepackage[french,vlined,tworuled,linesnumbered,algo2e]{algorithm2e}
\usepackage[Algorithme]{algorithm}
\usepackage{algpseudocode}
\usepackage{alltt}
\usepackage{lastpage}
\usepackage{multicol}
\usepackage{color}
\usepackage{moreverb}
\usepackage{graphicx}
\usepackage{paralist}
\usepackage{array}
\usepackage{tabularx}
\usepackage{parskip}
\usepackage{fancyhdr}
\usepackage{changepage}
\usepackage{minitoc}
\usepackage{float}
\usepackage[toc,page]{appendix}
\usepackage{hyperref}
\usepackage{wasysym}

% some definitions
\def\tb{\textbf}
\def\ti{\em}
\def\sc{\textsc}
\definecolor{dark_green}{rgb}{0,0.6,0}

% to set a blank page before an odd chapter page
\def\cleardoublepage{%
  \clearpage
  \ifodd\value{page}\else
    \thispagestyle{empty}%
    \hbox{}\newpage
  \fi
}

% Last page must be empty
\AtEndDocument{\thispagestyle{empty}}

% fancyhdr config
\setlength{\headheight}{15.2pt}
\fancyhead{}
\fancyhead[RE]{\slshape \leftmark}
\fancyhead[LO]{\slshape \rightmark}
\fancyfoot{}
\fancyfoot[LO,RE]{page \thepage\ sur \pageref{LastPage}}
\fancyfoot[LE,RO]{\small{\it{Christophe Enderlin}}}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\fancypagestyle{plain}{
	\fancyhf{}
	\renewcommand{\headrulewidth}{0pt}
	\renewcommand{\footrulewidth}{0pt}
}

% to get part title
\let\Oldpart\part
\newcommand{\parttitle}{}
\renewcommand{\part}[1]{\renewcommand{\parttitle}{#1}\Oldpart{#1}}

%customize lists
\frenchbsetup{ReduceListSpacing=true, CompactItemize=false}

% some commands
\newcommand{\red}[1]{\color{red}{#1}}
\newcommand{\green}[1]{\color{dark_green}{#1}}
\newcommand{\e}{\acute{e}}
\newcommand{\ee}{\grave{e}}
\newcommand{\eee}{\hat{e}}
\renewcommand{\And}{\textbf{ and }}

% algorithms customization
\renewcommand{\algorithmiccomment}[1]{{\color{dark_green}\hfill\(\triangleright\) {\small \textsf{#1}}}}
\algnewcommand\algorithmicto{\textbf{to}}
\algrenewtext{For}[3]{$\algorithmicfor\ #1 \gets #2\ \algorithmicto\ #3\ \algorithmicdo$}
%\algblock[Name]{Def}{Fin}
\algblock[Test]{switch}{endswitch}
\algrenewtext{endswitch}{\textbf{end switch}}
\algblockdefx[NAME]{case}{endcase}[1]{\textbf{case} (#1) :}{\textbf{break}}

% for titlepage.
\newcommand{\HRule}{\rule{\linewidth}{.5mm}}

% blank page
\newcommand{\blankpage}{\newpage\thispagestyle{empty}\mbox{}}

% to prevent footnotes to be split over several pages
\interfootnotelinepenalty=10000

% Hyperref.
\hypersetup{
	backref=true,
    pagebackref=true,
    hyperindex=true,
    colorlinks=true,
    breaklinks=true,
    urlcolor=blue,
    linkcolor=black,
    citecolor=black,
    bookmarks=true,
    bookmarksopen=true
}

% Minitoc.
\renewcommand{\mtctitle}{Sommaire}
%\setcounter{minitocdepth}{1}

\begin{document}

\chapter{Retrait de sommets d'un DST (suite des travaux)}
\section{Transfert}

\begin{algorithm}
\caption{: Transfert de n\oe uds du groupe courant vers un groupe appelant}\label{a:tr}
\begin{algorithmic}[1]
\Statex
\Procedure {transfert}{$st,\ right,\ cut\_pos$}
	\If{$(right = 1)$}
		\State $start \gets cut\_pos$
		\State $end \gets {\tt size}(me.brothers[stage]) - 1$
		\State $answer.stay\_id \gets me.brothers[stage][cut\_pos - 1].id$
	\Else
		\State $start \gets 0$
		\State $end \gets cut\_pos$
		\State $answer.stay\_id \gets me.brothers[st][cut\_pos + 1].id$
	\EndIf
	\Statex
	\For{i}{start}{end}
		\State $answer.rep\_array[i - start] = me.brothers[st][i]$
	\EndFor
	\Statex
	\State \Call {broadcast}{$me,\ st,\ {\tt cut\_node}{(st,\ right,\ cut\_pos)}$}
	\Statex
	\State \Return $answer$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{: Scinde un n\oe ud lors d'un transfert}\label{a:cn}
\begin{algorithmic}[1]
\Statex
\Procedure{cut\_node}{$stage,\ right,\ cut\_pos$}
	\State $pos\_me \gets {\tt index}(me.brothers[stage],\ me.id)$
	\Statex
	
	\If{$(right = 0)$}
		\State $start \gets 0$
		\State $end \gets cut\_pos$
		\State $new\_node \gets me.brothers[stage][cut\_pos + 1]$
	\Else
		\State $start \gets cut\_pos$
		\State $end \gets {\tt size}(me.brothers[stage]) - 1$
		\State $new\_node \gets me.brothers[stage][0]$
	\EndIf
	\Statex
	
	\If{$(pos\_me \geq start \And pos\_me \leq end)$}
		\State \Call {shift\_bro}{$stage + 1,\ new\_node,\ right$}
	\EndIf
	\Statex
	
	\If{$(right = 0)$}
		\If{$(pos\_me \leq cut\_pos)$}
			\State $start \gets cut\_pos + 1$
			\State $end \gets {\tt size}(me.brothers[stage] - 1)$
		\Else
			\State $start \gets 0$
			\State $end \gets cut\_pos$
		\EndIf
	\Else
		\If{$(pos\_me < cut\_pos)$}
			\State $start \gets cut\_pos$
			\State $end \gets {\tt size}(me.brothers[stage] - 1)$
		\Else
			\State $start \gets 0$
			\State $end \gets cut\_pos - 1$
		\EndIf
	\EndIf
	\Statex
	
	\State \Call {del\_member}{$stage,\ start,\ end$}
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{: Supprime une partie du groupe courant à un étage donné}\label{a:dm}
\begin{algorithmic}[1]
\Statex
\Procedure{del\_member}{$stage,\ start,\ end$}
	\State $nb\_del \gets end - start + 1$
	\If{$(nb\_del = 0)$}
		\State \Return
	\EndIf
	\Statex	\Comment{mémorise les n\oe uds à effacer avant de commencer}
	
	\For{i}{0}{nb\_del - 1}
		\State $id\_del[i] \gets me.brothers[stage][start + i].id$
	\EndFor
	\Statex		\Comment{boucle d'effacement}
	
	\For{i}{0}{nb\_del - 1}
		\If{$(id\_del[i] <> me.id)$}	\Comment{ne pas effacer '{\ti moi}'}
			\State $pos2del \gets {\tt index}(me.brothers[stage], id\_del[i])$
			\Statex
			
			\If{$(pos2del < {\tt size}(me.brothers[stage] - 1))$}
				\For{j}{pos2del}{{\tt size}(me.brothers[stage] - 1)}
					\State $me.brothers[stage][j] \gets me.brothers[stage][j + 1]$
				\EndFor
			\Else
				\State $j \gets pos2del$
			\EndIf
			\Statex
			
			\State $me.brothers[stage][j].id \gets -1$
			\Statex		\Comment{'{\ti moi}' n'est plus prédécesseur de $id\_del[i]$}
			
			\State \Call{send\_msg\_async}{$id\_del[i],\ {\tt del\_pred}(stage,\ me.id)$}			
		\EndIf
	\EndFor
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{: Décale les membres du groupe pour en accueillir un nouveau à la position de '{\ti moi}'. Le membre en trop est détruit.}
\begin{algorithmic}[1]
\Statex
\Procedure{shift\_bro}{$stage,\ new\_node,\ right$}
	\Statex		\Comment{s'assure de n'exécuter cette fonction qu'une fois (elle est diffusée par {\tt cut\_node})}
	\State $pos\_new\_node \gets {\tt index}(me.brothers[stage],\ new\_node.id)$
	\If{$(pos\_new\_node > -1)$}
		\State \Return
	\EndIf
	\Statex
	
	\State $pos\_me \gets {\tt index}(me.brothers[stage],\ me.id)$
	\Statex
	
	\If{$(right = 1)$}
		\If{$(pos\_me < b)$}
			\State $lost\_id \gets me.brothers[stage][pos\_me + 1].id$
			\State $me.brothers[stage][pos\_me + 1] \gets me.brothers[stage][pos\_me]$
		\Else
			\State Affiche un message d'erreur et stoppe la procédure
		\EndIf
	\Else
		\If{$(pos\_me > 0)$}
			\State $lost\_id \gets me.brothers[stage][pos\_me - 1].id$
			\State $me.brothers[stage][pos\_me - 1] \gets me.brothers[stage][pos\_me]$
		\Else
			\State Affiche un message d'erreur et stoppe la procédure
		\EndIf
	\EndIf
	\Statex
	
	\State $me.brothers[stage][pos\_me] \gets new\_node$
	\Statex
	\Statex		\Comment{'{\ti moi}' doit être un prédécesseur de {\ti new\_node}}
	\State \Call{send\_msg\_async}{$new\_node.id,\ {\tt add\_pred}(stage,\ me.id)$}
	
	\Statex		\Comment{'{\ti moi}' ne doit plus être un prédécesseur de {\ti lost\_id}}
	\State \Call{send\_msg\_async}{$lost\_id,\ {\tt del\_pred}(stage,\ me.id)$}
	
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{: Procédure exécutée par un n\oe ud qui quitte le DST}
\begin{algorithmic}[1]
\Statex
\Procedure{leave}{ }
	\Statex \Comment{travaille sur des copies des tables de routage}

	\State $cpy\_brothers \gets me.brothers$
	\State $cpy\_preds \gets me.preds$
	\Statex

	\For{stage}{0}{{\tt height}(me.brothers) - 1}
		\Statex \Comment{\textsc {informe mes prédécesseurs de mon départ}}
	
		\For{pred}{0}{{\tt size}(cpy\_preds[stage]) - 1}
			\Statex
		
			\If{$(cpy\_preds[stage][pred].id \neq me.id)$}
				\Statex
			
				\If{$(stage = 0)$}
					\State \Call{send\_msg\_async}{$cpy\_preds[stage][pred].id,\ {\tt del\_bro}(stage,\ me.id)$}
				\Else
					\Statex
					\State {$new\_rep\_id \gets$ un de mes frères de l'étage 0 choisi aléatoirement}
					\Statex \Comment{en informe le prédécesseur}
				
					\If{$(new\_rep\_id \neq me.id)$}
						\Statex
						\State \parbox{\textwidth}{\Call{send\_msg\_async}{$cpy\_preds[stage][pred].id,$
					
						$\qquad{\tt repl\_bro}(stage,\ new\_rep\_id)$}}
					\EndIf
				\EndIf
			\EndIf
		\EndFor \Comment{prédécesseur suivant}
		\Statex
		\Statex \Comment{\textsc{informe mes frères de mon départ}}
	
		\For{brother}{0}{{\tt size}(cpy\_brothers[stage]) - 1}
			\Statex
		
			\If{$(cpy\_brothers[stage][brother].id \neq me.id)$}
				\Statex
			
				\State \parbox{\textwidth}{\Call{send\_msg\_async}{$cpy\_brothers[stage][brother].id,$
			
				$\qquad{\tt del\_pred}(stage,\ me.id)$}}
			\EndIf
		\EndFor \Comment{frère suivant}
	\EndFor	\Comment{étage suivant}
	\Statex
	\Statex \Comment{\textsc{charge un de mes frères de traiter les fusions ou transferts}}

	\If{$({\tt size}(me.brothers[0]) \leq a)$}
		\Statex
		\State {$idx \gets$ index d'un de mes frères de l'étage 0}
		\State {\Call{send\_msg\_sync}{$me.brothers[0][idx].id,\ {\tt merge\_req}()$}}
	\EndIf
	
\EndProcedure
\end{algorithmic}
\end{algorithm}


\newcounter{partie}\stepcounter{partie}
\begin{algorithm}
\caption{: Traite les fusions ou transferts consécutifs à un départ}
\begin{algorithmic}[1]
\Procedure{merge\_request}{ }
	\Statex

	\State $stage \gets 0$
	\State $size\_last\_stage \gets 0$
	\Statex
	
	\Comment{parcourt l'ensemble des étages}
	\While{$({\tt size}(me.brothers[stage]) < a) \And stage < {\tt height}(me.brothers) - 1)$}
		\Statex
		
		\State $pos\_contact \gets {\tt merge\_or\_transfer}(me,\ stage)$
		\Statex
		
		\If{$(pos\_contact > -1)$}	\Comment{\textsc{une fusion est possible}}
			\Statex
			
			\State $transfer \gets 0$
			\State $pos\_me \gets {\tt index}(stage + 1,\ me.id)$
			\Statex
			
			\Statex	\Comment{demande au contact de réaliser une première fusion \ldots}
			
			\If{$(pos\_me > pos\_contact)$}
				\State $right \gets 11$
			\Else
				\State $right \gets 10$
			\EndIf
			\Statex
			
			\State \parbox{\textwidth}{\Call{send\_msg\_sync}{$me.brothers[stage + 1][pos\_contact].id,$
					
						$\qquad{\tt merge}(stage,\ pos\_me,\ pos\_contact,\ right,\ me.brothers[stage])$}}
						
			\Statex
			\Statex \Comment{\ldots puis lui demande de diffuser une tâche de fusion}
			
			\If{$(pos\_me > pos\_contact)$}
				\State $right \gets 1$
			\Else
				\State $right \gets 0$
			\EndIf
			\Statex
			
			\State \parbox{\textwidth}{\Call{send\_msg\_sync}{$me.brothers[stage + 1][pos\_contact].id,$
					
						$\qquad{\tt broadcast\_merge}(stage,\ pos\_me,\ pos\_contact,\ right,\ me.brothers[stage])$}}
			\Statex
			
			\State \Comment{après la fusion, l'étage supérieur contient deux représentants du même groupe}
			\Statex
			
			\State \Call{clean\_upper\_stage}{stage,\ pos\_me,\ pos\_contact} \Comment{exécution locale}
			\Statex \Comment{diffusion}
			
			\State \Call{broadcast}{$me,\ stage + 1,\ {\tt clean\_upper\_stage}{(stage,\ pos\_me,\ pos\_contact)}$}	
			\Statex
				
		\Else
		
		\algstore{algbrk}
		\end{algorithmic}
		\end{algorithm}
		
		\newpage
		
		\addtocounter{algorithm}{-1}
		\stepcounter{partie}
		\begin{algorithm}
		\caption{: \textsc{merge\_request} (partie \thepartie)}
		\begin{algorithmic}[1]
		\algrestore{algbrk}
			
			\Statex \State \Comment{\textsc{fusion impossible - il faut faire un transfert}}
			\Statex
			
			\State $pos\_me\_up \gets {\tt index}(stage + 1,\ me.id)$
			\Statex
			
			\If{$(pos\_me\_up = 0)$}
				\Statex
				
				\State $pos\_contact \gets 1$
				\State $right \gets 0$
				\State $cut\_pos \gets b - a - 1$
			\Else
				\Statex
				
				\State $pos\_contact \gets pos\_me\_up - 1$
				\State $right \gets 1$
				\State $cut\_pos \gets a$
			\EndIf
			\Statex
			
			\State $contact\_id \gets me.brothers[stage + 1][pos\_contact].id$
			\Statex
			
			\State $answer \gets $ \parbox[t]{\textwidth}{\Call{send\_msg\_sync}{$contact\_id,$
			
			$\qquad{\tt transfer}(stage,\ right,\ cut\_pos,\ me.id)$}}
			\Statex \Statex
			\State \Comment{\textsc{ajoute les n\oe uds re\c cus}}
			\Statex
			\State $current\_bro \gets me.brothers[stage]$	\Comment{sauvegarde l'étage courant}
			\Statex
			
			\State \Comment{chaque membre de la branche courante ajoute les n\oe uds re\c cus}
			\State \Call{br\_add\_bro\_array}{$stage,\ answer.rep\_array,\ \mathrm{mod}((right + 1),\ 2$}
			\Statex
			
			\State \Comment{chaque membre de la branche voisine ajoute les n\oe uds courants}
			\State \parbox{\textwidth}{\Call{send\_msg\_sync}{$answer.rep\_array[0].id,$
			
			$\qquad{\tt br\_add\_bro\_array}(stage,\ current\_bro,\ right)$}}
			\Statex
			
			\State \Comment{nettoyage de l'étage supérieur}
			\State \Comment{exécution locale}
			\State \Call{update\_upper\_stage}{$stage,\ pos\_contact,\ answer.stay\_id$}
			\Statex
			
			\State \Comment{diffusion}
			\State \parbox{\textwidth}{\Call{broadcast}{$me,\ stage + 1,$
			
			$\qquad{\tt update\_upper\_stage}{(stage,\ pos\_contact,\ answer.stay\_id)}$}}
			
		\EndIf
		\Statex
		
		\State $stage \gets stage + 1$ \Comment{étage suivant}
	\EndWhile
	
	\algstore{algbrk2}
	\end{algorithmic}
	\end{algorithm}
		
	\newpage
		
	\addtocounter{algorithm}{-1}
	\stepcounter{partie}
	\begin{algorithm}
	\caption{: \textsc{merge\_request} (partie \thepartie)}
	\begin{algorithmic}[1]
	\algrestore{algbrk2}
		
	\State \Comment{\textsc{traitement de la racine}}
	\Statex
	
	\State $i \gets 0$
	\While{$(me.brothers[0][i].id = me.id)$}
		\State $i \gets i + 1$
	\EndWhile
	\Statex
	
	\State $size\_last\_stage \gets $ \parbox[t]{\textwidth}{\Call{send\_msg\_sync}{$me.brothers[0][i].id,$
	
	$\qquad {\tt get\_size}({\tt height}(me.brothers) - 1)$}}
	\Statex
	
	\If{$(size\_last\_stage = 1)$}	\Comment{détruit la racine}
		\Statex
		
		\State \parbox{\textwidth}{\Call{broadcast}{$me,\ {\tt height}(me.brothers) - 1,\ {\tt del\_root}{({\tt height}(me.brothers))}$}}
	\EndIf
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{: regarde s'il faut faire une fusion ou un transfert. Retourne la position d'un contact pour la fusion ou -1 si tranfert}
\begin{algorithmic}[1]
\Procedure{merge\_or\_transfert}{stage}
	\Statex
	
	\State $idx\_bro \gets 0$
	\State $merge \gets 0$
	\Statex
	
	\While{$(merge = 0 \And idx\_bro < {\tt size}(me.brothers[stage + 1]))$}
		\Statex
		
		\If{$(me.brothers[stage + 1][idx\_bro].id \neq me.id)$}
			\Statex
			
			\State $size \gets $ \parbox[t]{\textwidth}{\Call{send\_msg\_sync}{$me.brothers[stage + 1].[idx\_bro].[id],$
			
			$\qquad {\tt get\_size}(stage)$}}
			\Statex
			
			\If{$(size \leq b - {\tt size}(me.brothers[stage]))$}
				\State $merge \gets 1$
			\EndIf
		\EndIf
		\Statex
		
		\State $idx\_bro \gets idx\_bro + 1$
	\EndWhile
	\Statex
	
	\If{$(merge = 1)$}
		\State \Return $idx\_bro - 1$
	\Else
		\State \Return $-1$
	\EndIf
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{: fusionne des n\oe uds ``orphelins'' (\emph{source}) au groupe courant (\emph{cible})}
\begin{algorithmic}[1]
\Procedure{merge}{nodes\_array,\ stage,\ pos\_me,\ pos\_contact,\ right}
	\Statex
	
	\If{$({\tt size}(nodes\_array) = {\tt size}(me.brothers[stage]))$} \Comment{déjà fait}
		\State \Return
	\EndIf
	\Statex
	
	\If{$({\tt size}(me.brothers[stage]) < a)$} \Comment{change le sens d'arrivée si 'moi' est dans la source}
		\State $right \gets \mathrm{mod}((right + 1),\ 2)$
	\EndIf
	\Statex
	
	\State $loc\_right \gets 0$
	\Statex
	
	\switch $\ (right)$
		\case{$0$}	\Comment{les nouveaux n\oe uds viennent de la gauche}
			\If{$({\tt index\_bro}(stage + 1,\ me.id) = 0)$}
				\State $loc\_right \gets 1$
			\Else
				\State $loc\_right \gets 0$
			\EndIf
		\endcase
		\Statex
		
		\case{$1$}	\Comment{les nouveaux n\oe uds viennent de la droite}
		\endcase
		\Statex
		
		\case{$10$}	\Comment{les nouveaux n\oe uds viennent de la gauche}
		\endcase
		\Statex
		
		\case{$11$}	\Comment{les nouveaux n\oe uds viennent de la droite}
		\endcase
	\endswitch
	
\EndProcedure
\end{algorithmic}
\end{algorithm}

\end{document}











