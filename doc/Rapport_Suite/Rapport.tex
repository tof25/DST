Rappel de la situation:

Dans la version précédente, le choix avait été fait d'avoir simplement un seul
process par hôte. Des tests approfondis ont montré que ça ne paraîssait pas une
bonne solution. Voici un exemple de cas de figure qui pose problème:

2 noeuds intègrent le DST via un même leader:
 * Node 14 --> Node 121 --> Node 42
   puis
 * Node 249 --> Node 121 --> Node 42
   Cette arrivée de Node 249 provoque de scissions et un ajout d'étage

 - Node 121 reçoit bien ACK_CNX_REQ/14 de 42 mais le stocke parce qu'il est
   déjà en attente de ACK_CNX_REQ/249 envoyé à 42

 - Node 14 ne recevant pas la réponse de 121 reste en 'b'. Il ne peut donc
   répondre à ADD_STAGE/249 ==> DEADLOCK

On envisage donc d'utiliser plusieurs process par hôte pour séparer les tâches :
un qui reçoit les requêtes et un autre qui les traite, par exemple.

Pour rappel, voici une vue d'ensemble de l'intégration d'un nouvel arrivant

<DST_Arrival.png>
<DST_Arrival_001.png>

Voici maintenant le schéma général de la gestion de ces process multiples:

<Call_procs.png>

On utilise un maximum de trois process par noeud:
    - Main_Proc:
      Comme son nom l'indique, c'est le process principal en charge des
      initialisations et de la création du process Tasks_Queue

    - Tasks_Queue:
      Ce process est chargé de faire tourner la fonction run_tasks_queue() qui
      traite la file des tâches CNX_REQ reçues. Cette fonction tourne pendant
      toute la durée de la simulation.

    - Handle_Task:
      Ce process est créé par run_tasks_queue() pour exécuter les tâches
      suivantes : CNX_REQ, BR_SPLIT et BR_CS_REQ
      De la sorte, ces tâches peuvent s'exécuter sur leur propre process et les
      écoutes ne peuvent plus être mélangées.


Dans le détail.

Fonctionnement de run_tasks_queue
<Algo_run_tasks_queue.png>

Comme déjà précisé, la file tasks_queue contient toutes les demandes de
connection (c'est à dire toutes les tâches CNX_REQ) reçues. run_tasks_queue()
est donc chargé de traiter les requêtes présentes dans cette file, par ordre de
priorité. (noter l'étape de tri de la file avant exécution suivante)

Après avoir traité les tâches différées (voir détails plus loin), on s'occupe de
la file proprement dite.

MAX_CNX ne sert qu'à afficher un message en cas de nombreuses tentatives
d'exécution d'une même requête.

launch_fork_process() (voir détails plus loin) est chargée d'exécuter la
requête courante. Ici, elle confie l'éxécution de la requête à un process fils
Handle_task et rend la main juste après. D'où la nécessité de la variable
Run_state pour savoir si l'exécution de la tâche est terminée ou pas.
