@startuml

start

:cpt <-- 0
idx <-- 0
val_ret <-- OK
nb_elems <-- taille de delayed_tasks;

if (state.active = 'u' && delayed_tasks non vide ?) then (yes)

    while (cpt < nb_elems && state.active = 'u' ?)
        :task <-- delayed_tasks(cpt);
        if (task.type == CNX_GROUPS ?) then (yes)
            if (task.args.new_node_id == state.new_node_id ?) then (yes)
                :remove delayed_tasks(cpt);
                :cpt--;
                :handle_tasks(task);
            endif
        endif
        :cpt++;
    endwhile
endif

if (state.active = 'a' && delayed_tasks non vide ?) then (yes)
    if (nb_elems > 0 ?) then (yes)
        :is_contact <-- 0\nbuf_new_node_id <-- -1;
        repeat
            :idx <-- 0;
            while (idx < nb_elems && state.active == 'a' ?)
                :task <-- delayed_tasks(idx);
                :is_contact <-- (task.sender_id == task.args.new_node_id ?);
                :buf_new_node_id <-- task.args.new_node_id;
                :val_ret <-- handle_tasks(task);
                if (val_ret == UPDATE_NOK ?) then (yes)
                    if (state.active == 'a' &&\nme.cs_req == 1 &&\nme.cs_new_id == buf_new_node_id ?) then (yes)
                        :reset me.cs_req;
                    endif
                endif
                if (val_ret == OK ||\nval_ret == UPDATE_OK ||\n(val_ret == UPDATE_NOK && !is_contact) ||\nval_ret == STORED ?) then (yes)
                    :remove delayed_tasks(idx);
                    :nb_elems--;
                else (no)
                    :idx++;
                endif
            endwhile
        repeatwhile (val_ret == OK &&\nnb_elems > 0 &&\nstate.active == 'a' ?)
    endif
endif

stop

@enduml
