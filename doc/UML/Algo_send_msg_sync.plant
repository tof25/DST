@startuml

start

partition Send_Request {
:init req data;
:create task containing req;
:loop_cpt <-- 0;

repeat
    :send task (with isend);
    :push req onto sync_answers\n(if not already done);
    while (communication not finished &&\nmax_wait not reached ?) is (yes)
        :sleep for a while;
    endwhile
    if (max_wait reached || comm_status == MSG_TRANSFER_FAILURE ?) then (yes)
        :res <-- MSG_TRANSFER_FAILURE;
        stop
    else (no)
        :res <-- comm_status;
    endif
    if (res == MSG_TIMEOUT ?) then (yes)
        :loop_cpt++;
    else (no)
    endif

repeat while (res == MSG_TIMEOUT && loop_cpt < max_loops ?) is (try again)
}

if (loop_cpt >= max_loops ||\nres != MSG_OK) then (yes : sending failed)
    :display error message;
    stop
else (no : send success)
partition Answer_Receive {
    :res <-- MSG_OK;

    :success <-- false;

    while (success == false &&\n(res != MSG_TIMEOUT ||\nreq.type != GET_REP)) is (yes : answer not received yet)
        :receive task;
        if (res == MSG_OK ?) then (no : reception failure)
            :display error message;
        else (yes : task received)
            if (request or answer ?) then (request)
                if (rcv_req.type == CNX_REQ ?) then (yes)
                    :push rcv_req on tasks_queue;
                else (no)
                    :handle_task(task);
                endif
                :look into sync_answers;
                if (answer received meanwhile ?) then (yes)
                    :pop record from sync_answers;
                    :success <-- true;
                else (no)
                endif
            else (answer)
                if (expected sync answer ?) then (yes)
                    :pop record from sync_answers;
                    :success <-- true;
                else (no)
                    if (other sync answer ?) then (yes)
                        :record rcv_ans into sync_answers;
                    else (not a sync expected answer)
                        if (async expected answer ?) then (yes)
                            :record rcv_ans into async_answers;
                        else (not expected answer)
                            :discard rcv_ans;
                        endif
                    endif
                endif
            endif
        endif
    endwhile (no : stop listening)
}
    if (res == MSG_TIMEOUT &&\ncpy_req.type == GET_REP) then (GET_REP timeout)
        if (sync_answers is empty ?) then (no)
            :pop GET_REP task from proc sync_answers dynar;
        else (yes)
        endif
    else (no)
    endif
endif

:return res;

stop

@enduml
