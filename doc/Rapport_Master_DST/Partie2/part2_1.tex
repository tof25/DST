% !TEX root = ../RapportM2.tex

\chapter{Retrait de sommets d'un DST (suite des travaux)}
\section{Transfert}

\begin{algorithm}
\caption{: Transfert de n\oe uds du groupe courant vers un groupe appelant}\label{a:tr}
\begin{algorithmic}[1]
\Statex
\Procedure {transfert}{$st,\ right,\ cut\_pos$}
	\If{$(right = 1)$}
		\State $start \gets cut\_pos$
		\State $end \gets {\tt size}(me.brothers[stage]) - 1$
		\State $answer.stay\_id \gets me.brothers[stage][cut\_pos - 1].id$
	\Else
		\State $start \gets 0$
		\State $end \gets cut\_pos$
		\State $answer.stay\_id \gets me.brothers[st][cut\_pos + 1].id$
	\EndIf
	\Statex
	\For{i}{start}{end}
		\State $answer.rep\_array[i - start] = me.brothers[st][i]$
	\EndFor
	\Statex
	\State \Call {broadcast}{$me,\ st,\ {\tt cut\_node}{(st,\ right,\ cut\_pos)}$}
	\Statex
	\State \Return $answer$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{: Scinde un n\oe ud lors d'un transfert}\label{a:cn}
\begin{algorithmic}[1]
\Statex
\Procedure{cut\_node}{$stage,\ right,\ cut\_pos$}
	\State $pos\_me \gets {\tt index}(me.brothers[stage],\ me.id)$
	\Statex
	
	\If{$(right = 0)$}
		\State $start \gets 0$
		\State $end \gets cut\_pos$
		\State $new\_node \gets me.brothers[stage][cut\_pos + 1]$
	\Else
		\State $start \gets cut\_pos$
		\State $end \gets {\tt size}(me.brothers[stage]) - 1$
		\State $new\_node \gets me.brothers[stage][0]$
	\EndIf
	\Statex
	
	\If{$(pos\_me \geq start$ \And $pos\_me \leq end)$}
		\State \Call {shift\_bro}{$stage + 1,\ new\_node,\ right$}
	\EndIf
	\Statex
	
	\If{$(right = 0)$}
		\If{$(pos\_me \leq cut\_pos)$}
			\State $start \gets cut\_pos + 1$
			\State $end \gets {\tt size}(me.brothers[stage] - 1)$
		\Else
			\State $start \gets 0$
			\State $end \gets cut\_pos$
		\EndIf
	\Else
		\If{$(pos\_me < cut\_pos)$}
			\State $start \gets cut\_pos$
			\State $end \gets {\tt size}(me.brothers[stage] - 1)$
		\Else
			\State $start \gets 0$
			\State $end \gets cut\_pos - 1$
		\EndIf
	\EndIf
	\Statex
	
	\State \Call {del\_member}{$stage,\ start,\ end$}
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{: Supprime une partie du groupe courant à un étage donné}\label{a:dm}
\begin{algorithmic}[1]
\Statex
\Procedure{del\_member}{$stage,\ start,\ end$}
	\State $nb\_del \gets end - start + 1$
	\If{$(nb\_del = 0)$}
		\State \Return
	\EndIf
	\Statex	\Comment{mémorise les n\oe uds à effacer avant de commencer}
	
	\For{i}{0}{nb\_del - 1}
		\State $id\_del[i] \gets me.brothers[stage][start + i].id$
	\EndFor
	\Statex		\Comment{boucle d'effacement}
	
	\For{i}{0}{nb\_del - 1}
		\If{$(id\_del[i] <> me.id)$}	\Comment{ne pas effacer '{\ti moi}'}
			\State $pos2del \gets {\tt index}(me.brothers[stage], id\_del[i])$
			\Statex
			
			\If{$(pos2del < {\tt size}(me.brothers[stage] - 1))$}
				\For{j}{pos2del}{{\tt size}(me.brothers[stage] - 1)}
					\State $me.brothers[stage][j] \gets me.brothers[stage][j + 1]$
				\EndFor
			\Else
				\State $j \gets pos2del$
			\EndIf
			\Statex
			
			\State $me.brothers[stage][j].id \gets -1$
			\Statex		\Comment{'{\ti moi}' n'est plus prédécesseur de $id\_del[i]$}
			
			\State \Call{send\_msg\_async}{$id\_del[i],\ {\tt del\_pred}(stage,\ me.id)$}			
		\EndIf
	\EndFor
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{: Décale les membres du groupe pour en accueillir un nouveau à la position de '{\ti moi}'. Le membre en trop est détruit.}
\begin{algorithmic}[1]
\Statex
\Procedure{shift\_bro}{$stage,\ new\_node,\ right$}
	\Statex		\Comment{s'assure de n'exécuter cette fonction qu'une fois (elle est diffusée par {\tt cut\_node})}
	\State $pos\_new\_node \gets {\tt index}(me.brothers[stage],\ new\_node.id)$
	\If{$(pos\_new\_node > -1)$}
		\State \Return
	\EndIf
	\Statex
	
	\State $pos\_me \gets {\tt index}(me.brothers[stage],\ me.id)$
	\Statex
	
	\If{$(right = 1)$}
		\If{$(pos\_me < b)$}
			\State $lost\_id \gets me.brothers[stage][pos\_me + 1].id$
			\State $me.brothers[stage][pos\_me + 1] \gets me.brothers[stage][pos\_me]$
		\Else
			\State Affiche un message d'erreur et stoppe la procédure
		\EndIf
	\Else
		\If{$(pos\_me > 0)$}
			\State $lost\_id \gets me.brothers[stage][pos\_me - 1].id$
			\State $me.brothers[stage][pos\_me - 1] \gets me.brothers[stage][pos\_me]$
		\Else
			\State Affiche un message d'erreur et stoppe la procédure
		\EndIf
	\EndIf
	\Statex
	
	\State $me.brothers[stage][pos\_me] \gets new\_node$
	\Statex
	\Statex		\Comment{'{\ti moi}' doit être un prédécesseur de {\ti new\_node}}
	\State \Call{send\_msg\_async}{$new\_node.id,\ {\tt add\_pred}(stage,\ me.id)$}
	
	\Statex		\Comment{'{\ti moi}' ne doit plus être un prédécesseur de {\ti lost\_id}}
	\State \Call{send\_msg\_async}{$lost\_id,\ {\tt del\_pred}(stage,\ me.id)$}
	
\EndProcedure
\end{algorithmic}
\end{algorithm}